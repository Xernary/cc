#!/usr/bin/env python3

# Importa la libreria di pwntools
from pwn import *
from binascii import hexlify


def main():
    '''
    remote(hostname, port) apre una socket e ritorna un object
    che può essere usato per inviare e ricevere dati sulla socket  
    '''
    HOST = "software-18.challs.olicyber.it"
    PORT = 13001
    r = remote(HOST, PORT)

    # .send() può essere invocato sull'oggetto ritornato da remote() per inviare dati
    #r.send(b"Ciao!")

    # .sendline() è identico a .send(), però appende un newline dopo i dati
    #r.sendline(b"Ciao!")

    # .sendafter() e .sendlineafter() inviano la stringa "Ciao!"
    #r.sendafter(b"... Invia un qualsiasi carattere per iniziare ...", b"k")


    # .recvuntil() legge dalla socket finchè non viene incontrata la stringa "something"
    def cycle():
        for i in range(7):
            data = r.recvline()
            print(data)
        r.sendline(b'a')
        print('SENT a')

    cycle()
    count = 0
    while 1:
        string = r.recvline()
        data = r.recvuntil(b'[+] Result : ')
        print(string)
        print(data)
        data = string.decode("utf-8")
        result = b'\x00'
        if "restituiscimi" in data:
            if count==0:
                number = int(data.split(" ")[5+7], 0)
                bits = (data.split(" ")[8+7])[:2]
            else:
                number = int(data.split(" ")[5], 0)
                bits = (data.split(" ")[8])[:2]

            print("BITS = " + str(bits))
            print("NUMBER = " + str(number))
            if "64" in bits:
                #64
                result = p64(number) 
            else:
                #32
                result = p32(number)
            print(b'RESULT = ' + hexlify(result))
            r.send(result)

        if count==99:
            cycle()
        count=count+1
    r.recvline()





    # permette di interagire con la connessione direttamente dalla shell
    #r.interactive()

    # chiude la socket
    #r.close()


if __name__ == "__main__":
    main()
